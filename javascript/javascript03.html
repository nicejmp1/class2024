<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 데이터 실행하기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">

</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li><a href="javascript02.html">데이터 불러오기</a></li>
                <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
            <ul>
                <li><a href="object01.html">문자열 객체</a></li>
                <li><a href="object02.html">배열 객체</a></li>
                <li><a href="object03.html">수학 객체</a></li>
                <li><a href="object04.html">숫자 객체</a></li>
                <li><a href="object05.html">브라우저 객체</a></li>
                <li><a href="object06.html">요소 객체</a></li>
                <li><a href="object07.html">이벤트 객체</a></li>

            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="#sample01">01. 함수 : 선언적 함수 </a></li>
                <li><a href="#sample02">02. 함수 : 익명 함수 </a></li>
                <li><a href="#sample03">03. 함수 : 매개변수 함수 </a></li>
                <li><a href="#sample04">04. 함수 : 리턴값 함수 </a></li>
                <li><a href="#sample05">05. 함수 : 매개변수 + 리턴값 함수 </a></li>

                <li><a href="#sample06">06. 화살표 함수 : 선언적 함수 </a></li>
                <li><a href="#sample07">07. 화살표 함수 : 익명 함수 </a></li>
                <li><a href="#sample08">08. 화살표 함수 : 매개변수 함수 </a></li>
                <li><a href="#sample09">09. 화살표 함수 : 리턴값 함수 </a></li>
                <li><a href="#sample10">10. 화살표 함수 : 매개변수 + 리턴값 함수 </a></li>

                <li><a href="#sample11">11. 함수 유형 : 함수와 매개변수를 이용한 형태 </a></li>
                <li><a href="#sample12">12. 함수 유형 : 함수와 변수를 이용한 형태 </a></li>
                <li><a href="#sample13">13. 함수 유형 : 함수와 배열를 이용한 형태 </a></li>
                <li><a href="#sample14">14. 함수 유형 : 함수와 객체를 이용한 형태 </a></li>
                <li><a href="#sample15">15. 함수 유형 : 함수와 객체 및 배열를 이용한 형태 </a></li>
                <li><a href="#sample16">16. 함수 유형 : 객체 안에 함수를 이용한 형태 </a></li>
                <li><a href="#sample17">17. 함수 유형 : 객체 생성자 함수 </a></li>
                <li><a href="#sample18">18. 함수 유형 : 프로토타입 함수 </a></li>
                <li><a href="#sample19">19. 함수 유형 : 객체 리터릴 함수 </a></li>

                <li><a href="#">20. 함수 : 즉시실행 함수</a></li>
                <li><a href="#">21. 함수 : 파라미터 함수</a></li>
                <li><a href="#">22. 함수 : 재귀 함수</a></li>
                <li><a href="#">23. 함수 : 콜백 함수</a></li>
                <li><a href="#">24. 함수 : 비동기 방식 : 콜백 함수</a></li>
                <li><a href="#">25. 함수 : 비동기 방식 : 프로미스</a></li>
                <li><a href="#">26. 함수 : 비동기 방식 : asyne/await</a></li>
                <li><a href="#">27. 함수 : 중첩 함수</a></li>
                <li><a href="#">28. 함수 : 클로저</a></li>

                <li><a href="#">29. 클래스 : 기본</a></li>
                <li><a href="#">30. 클래스 : 상속</a></li>

            </ul>
        </div>
        <!-- //main__menu -->

        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01. 함수 : 선언적 함수</h3>
                <p>
                    선언적 함수는 코드의 상단에 function 키워드를 사용하여 정의된 함수를 말합니다. 이 함수는 선언된 위치와 관계없이 어디서든 호출할 수 있으며, 코드 실행 전에 메모리에
                    할당되어 호이스팅에 영향을 받습니다. 다른 말로는 함수 선언문이라고도 불리며, 전역 스코프나 해당 함수가 정의된 스코프에서 사용될 수 있습니다. 함수가 선언될 때마다 함수 객체가
                    만들어지며, 이후에 언제든 해당 함수를 호출할 수 있습니다.
                </p>
                <pre><code>{
    function func() {
        console.log("01. 함수가 실행되었습니다.");
    }
    func();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            01. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->

            <div id="sample02" class="sample">
                <h3>02. 함수 : 익명 함수</h3>
                <p>
                    익명 함수는 이름이 없는 함수를 의미합니다. 일반적으로 함수를 선언할 때 이름을 명시하지 않고 사용됩니다. 대부분의 경우 함수 표현식이나 콜백 함수로 사용되며, 다른 함수 내에서
                    일회성으로 사용될 때 유용합니다. 예를 들어, 변수에 할당하여 사용하거나 다른 함수의 매개변수로 전달되어 호출될 수 있습니다. 이러한 함수는 주로 한 번만 필요하거나 특정 작업을
                    처리하는 데에만 사용되므로 이름을 붙이지 않고도 충분히 이해할 수 있습니다. 이름이 없어도 함수의 동작이나 목적을 파악하기 쉽고 간결한 코드를 작성할 수 있도록 해줍니다.
                </p>
                <pre><code>{
    const func = function () {
        console.log("02. 함수가 실행되었습니다.");
    }
    func();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            02. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->

            <div id="sample03" class="sample">
                <h3>03. 함수 : 매개변수 함수</h3>
                <p>
                    매개변수 함수는 다른 함수의 매개변수로 전달되는 함수를 말합니다. 위 코드에서는 "func"와 "func1"이라는 두 함수를 정의하고 있습니다. 두 함수 모두 하나의 매개변수를
                    받아들이고, 이 매개변수를 콘솔에 출력하는 역할을 수행합니다. 따라서 이 두 함수는 문자열을 받아들이는 매개변수 함수로 정의됩니다.
                </p>
                <pre><code>{
   // 선언적 함수
    function func(str) {
        console.log(str);
    }
    func("03. 함수가 실행되었습니다.");

    //익명 함수
    const func1 = function (str) {
        console.log(str);
    }
    func("03. 함수가 실행되었습니다.");
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            03. 함수가 실행되었습니다. <br>
                            03. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample03 -->

            <div id="sample04" class="sample">
                <h3>04. 함수 : 리턴값 함수</h3>
                <p>
                    리턴값 함수는 호출되었을 때 결과를 반환하는 함수를 말합니다. 이 함수는 실행된 결과를 반환하여 해당 함수가 호출된 곳에서 그 값을 받아 사용할 수 있습니다. 보통 함수 내에서
                    계산된 값을 반환하거나 다른 작업의 결과를 반환하는데 사용됩니다. 반환된 값은 함수를 호출한 코드에서 변수에 할당하거나 다른 함수의 인자로 전달하여 활용될 수 있습니다
                </p>
                <pre><code>{
    //선언적 함수
    function func() {
        return "04. 함수가 실행되었습니다."
    }
    console.log(func());

    //익명 함수
    const func1 = function () {
        return "04. 함수가 실행되었습니다."
    }
    console.log(func1());
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            04. 함수가 실행되었습니다. <br>
                            04. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample04 -->

            <div id="sample05" class="sample">
                <h3>05. 함수 : 매개변수 + 리턴값 함수 </h3>
                <p>

                    주어진 코드에서 함수는 외부로부터 문자열을 입력받아들이고, 그 입력값을 그대로 반환합니다. 이는 매개변수와 리턴값을 가진 함수의 기본적인 형태입니다. 함수는 입력값을 받아들인 후
                    내부에서 특정 작업을 수행하거나 가공한 후 결과를 반환하는데, 여기서는 입력값을 그대로 반환하여 출력합니다. 이렇게 하면 함수는 입력값에 따라 결과를 다르게 반환할 수 있으며,
                    이는 함수의 다양한 활용성을 보여줍니다. 함수는 코드의 재사용성과 가독성을 높이는데 유용하며, 다양한 기능을 제공할 수 있습니다
                </p>
                <pre><code>{
    // 선언적 함수
    function func(str) {
        return str;
    }
    console.log(func("05. 함수가 실행되었습니다."));

    // 익명 함수
    const func1 = function (str) {
        return str;
    }
    console.log(func1("05. 함수가 실행되었습니다."));
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            05. 함수가 실행되었습니다. <br>
                            05. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample05 -->

            <div id="sample06" class="sample">
                <h3>06. 화살표 함수 : 선언적 함수 </h3>
                <p>
                    화살표 함수는 함수를 더 간결하게 정의하는데 사용됩니다. 기존의 함수 선언 방식인 function 키워드 대신 =>를 사용하여 함수를 정의합니다. 주로 한 줄로 간단한 작업을 하는
                    함수를 정의할 때 유용하게 활용되며, 익명 함수를 변수에 할당할 때 자주 사용됩니다. 이를 통해 코드를 더 읽기 쉽고 간결하게 만들어줍니다
                </p>
                <pre><code>{
    // 선언적 함수 
    function func() {
        console.log("06. 함수가 실행되었습니다.")
    }
    func();

    // 선언적 함수를 화살표 함수로 바꿈
    func = () => {
        console.log("06. 함수가 실행되었습니다.")
    }
    func();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            06. 함수가 실행되었습니다. <br>
                            06. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample06 -->

            <div id="sample07" class="sample">
                <h3>07. 화살표 함수 : 익명 함수</h3>
                <p>
                    화살표 함수는 익명 함수를 더 간결하고 명확하게 작성할 수 있는 ES6 문법입니다. 익명 함수란 이름이 없는 함수를 말하며, 주로 콜백 함수나 간단한 함수를 정의할 때 사용됩니다.
                    화살표 함수는 익명 함수를 활용하여 함수를 정의하는 것이므로, 익명 함수의 특성을 그대로 가지고 있습니다. 이를 통해 화살표 함수는 코드를 더 간결하게 표현할 수 있고, 일반적으로
                    함수의 선언을 더 짧고 명확하게 만들어줍니다.
                </p>
                <pre><code>{
    //익명 함수
    const func = function () {
        console.log("07. 함수가 실행되었습니다.")
    };
    func();

    // 익명함수를 화살표 함수로 변경
    const func1 = () => {
        console.log("07. 함수가 실행되었습니다.")
    };
    func1();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            07. 함수가 실행되었습니다. <br>
                            07. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample07 -->

            <div id="sample08" class="sample">
                <h3>08. 화살표 함수 : 매개변수 함수 </h3>
                <p>
                    매개변수는 함수가 호출될 때 함수에 전달되는 값을 받아들이는 변수를 말합니다. 함수를 정의할 때 괄호 () 안에 매개변수를 지정하여 함수가 호출될 때 이를 사용할 수 있습니다.
                    매개변수는 함수 내부에서 변수처럼 사용되며, 함수가 호출될 때 전달된 값(argument)에 대응됩니다. 화살표 함수에서 매개변수는 화살표 =>를 통해 함수의 몸체와 구분되며,
                    함수의 인자로 동작합니다. 이를 통해 함수가 호출될 때 매개변수에 전달된 값을 함수 내부에서 사용할 수 있습니다.
                </p>
                <pre><code>{
    // 선언적 함수 
    func = (str) => {
        console.log(str);
    }
    func("08. 함수가 실행되었습니다.");
        
    // 익명 함수
    const func1 = (str) => {
        console.log(str);
    }
    func1("08. 함수가 실행되었습니다.");
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            08. 함수가 실행되었습니다. <br>
                            08. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample08 -->

            <div id="sample09" class="sample">
                <h3>09. 화살표 함수 : 리턴값 함수(결과, 종료) </h3>
                <p>
                    화살표 함수는 ES6에서 도입된 간결한 함수 표현식으로, 함수를 더 간결하게 정의할 수 있는 문법입니다. 함수 내부에서 return 키워드를 사용하여 명시적으로 반환값을 지정하며,
                    호출한 곳으로 그 값을 전달합니다. 이를 통해 함수의 실행 결과를 간결하게 반환할 수 있고, 코드의 가독성을 향상시킵니다.
                </p>
                <pre><code>{
    //선언적 함수
    func = () => {
        return "09. 함수가 실행되었습니다."
    }
    console.log(func());

    //익명 함수
    const func1 = () => {
        return "09. 함수가 실행되었습니다."
    }
    console.log(func1());
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            09. 함수가 실행되었습니다. <br>
                            09. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample09 -->

            <div id="sample10" class="sample">
                <h3>10. 화살표 함수 : 매개변수 + 리턴값 함수 </h3>
                <p>

                    화살표 함수는 ES6에서 추가된 새로운 함수 선언 방식입니다. 이 함수는 기존의 함수 선언 방식보다 더 간결하고 명확한 구문을 제공합니다.
                    화살표 함수는 다음과 같은 특징을 가지고있습니다. <br>

                    매개변수: 함수의 매개변수를 괄호로 묶어서 받아들입니다. 매개변수가 하나인 경우에는 괄호를 생략할 수 있습니다. <br>
                    화살표 (=>): 화살표 함수를 정의하는데 사용됩니다. 매개변수와 함수의 몸체를 구분하는 역할을 합니다. <br>
                    함수 몸체: 함수의 몸체는 중괄호 {}로 감싸지지 않고, 단일 표현식이거나 여러 표현식이 될 수 있습니다. <br>
                    리턴값: 함수 몸체가 단일 표현식으로 이루어진 경우, return 키워드와 중괄호를 생략하여 바로 결과를 반환할 수 있습니다. <br>
                    이러한 특징들을 이용하면 함수를 더 간결하게 작성할 수 있고, 특히 간단한 작업을 하는 함수를 정의할 때 유용합니다.
                </p>
                <pre><code>{
    // 익명 함수(화살표 함수) + 매개변수 + 리턴값
    const func = (str) => {
        return str;
    }
    console.log(func("10. 함수가 실행되었습니다."));

    // 매개변수가 하나이면 괄호 생략 가능
    const func2 = str => {
        return str;
    }
    console.log(func2("10. 함수가 실행되었습니다."));

    // 리턴 생략
    const func3 = str => str;
    console.log(func3("10. 함수가 실행되었습니다."));

    // 선언적 함수(가독성X)
    func4 = str => str;
    console.log(func4("10. 함수가 실행되었습니다."));
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            10. 함수가 실행되었습니다. <br>
                            10. 함수가 실행되었습니다. <br>
                            10. 함수가 실행되었습니다. <br>
                            10. 함수가 실행되었습니다. <br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample10 -->

            <div id="sample11" class="sample">
                <h3>11. 함수 유형 : 함수와 매개변수를 이용한 형태 (템플릿 리터럴)</h3>
                <p>
                    템플릿 리터럴은 백틱(``)으로 감싸진 문자열 안에서 변수나 표현식을 쉽게 삽입할 수 있는 기능입니다. 이를 사용하면 문자열 연결 연산자인 '+'를 사용할 필요 없이 `${}`
                    구문을 통해 변수를 삽입할 수 있습니다. 템플릿 리터럴은 가독성을 높이고 복잡한 문자열을 보다 간결하게 표현할 수 있으며, 변수와 문자열을 보다 쉽게 조합하여 출력할 수 있습니다.
                </p>
                <pre><code>{
    function func(num, str) {
        console.log(num + ". " + str);
        console.log(`${num}. ${str}`);
    }
    func(11, "함수가 실행되었습니다.");
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            11. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample11 -->

            <div id="sample12" class="sample">
                <h3>12. 함수 유형 : 함수와 변수를 이용한 형태</h3>
                <p>
                    함수와 변수를 함께 사용하는 방식은 간단하고 직관적이며 코드를 더 읽기 쉽게 만듭니다. 이는 코드를 간결하게 유지할 수 있고, 함수 호출 시 필요한 정보를 명시적으로 전달합니다.
                    하지만 이러한 형태는 변수의 개수가 많아질수록 함수 호출이 복잡해질 수 있으며, 함수 외부에서 변수의 값을 변경하거나 전역 변수를 사용할 경우 코드의 유연성과 관리가 어려워질 수
                    있습니다.
                </p>
                <pre><code>{
    const num = 12;
    const str = "함수가 실행되었습니다.";

    function func(num, str) {
        console.log(`${num}. ${str}`);
    }
    func(num, str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            12. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample12 -->

            <div id="sample13" class="sample">
                <h3>13. 함수 유형 : 함수와 배열를 이용한 형태</h3>
                <p>
                    함수와 배열을 함께 사용하면 데이터를 효율적으로 관리하고 처리할 수 있습니다. 배열을 사용하면 여러 데이터를 하나의 변수에 저장할 수 있으며, 함수를 통해 배열의 요소를 처리할 수
                    있습니다. 이는 코드의 가독성을 높이고 유지보수성을 향상시키지만, 함수 호출 시 각 배열 요소를 직접 전달해야 하는 불편함이 있을 수 있습니다. 또한, 배열의 크기나 구조가 변경될
                    경우 해당 변경 사항을 모든 함수 호출 코드에서 반영해야 하는 점이 단점으로 작용할 수 있습니다.
                </p>
                <pre><code>{
    const num = [13, 14];
    const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."];

    function func(num, str) {
        console.log(`${num}. ${str}`);
    }
    func(num[0], str[0]);
    func(num[1], str[1]);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            13. 함수가 실행되었습니다. <br>
                            14. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample13 -->

            <div id="sample14" class="sample">
                <h3>14. 함수 유형 : 함수와 객체를 이용한 형태</h3>
                <p>
                    함수와 객체를 이용한 방법은 데이터를 객체로 구조화하고 함수를 통해 처리하는 유용한 방법입니다. 객체는 데이터를 쉽게 관리하고 전달할 수 있으며, 함수를 통해 데이터를 가공하거나
                    출력할 수 있습니다. 이러한 방법은 코드의 가독성을 높이고 유지보수성을 향상시키지만, 함수 호출 시 객체의 특정 속성을 전달해야 하는 불편함이 있을 수 있습니다. 또한, 객체의
                    구조가 복잡할 경우 객체 내 속성을 접근하고 관리하는 것이 번거로울 수 있습니다.
                </p>
                <pre><code>{
    const info = {
        num: 15,
        str: "함수가 실행되었습니다."
    }
    function func(num, str) {
        console.log(`${num}. ${str}`);
    }
    func(info.num, info.str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            15. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample14 -->

            <div id="sample15" class="sample">
                <h3>15. 함수 유형: 함수와 객체 및 배열를 이용한 형태</h3>
                <p>
                    함수 내부에 객체가 있는 형태는 데이터를 객체로 구조화하고 함수를 통해 각 객체를 처리하는 방식입니다. 이는 데이터를 관리하고 처리하는 데 편리하며, 코드의 가독성을 높이고
                    유지보수성을 향상시킵니다. 하지만 함수 호출 시 객체의 특정 속성을 전달해야 하므로 인자로 전달해야 하는 정보가 많아질수록 호출 코드가 복잡해질 수 있습니다. 또한, 객체의 구조가
                    복잡할수록 객체 내 속성을 접근하고 관리하는 것이 번거로울 수 있습니다.
                </p>
                <pre><code>{
    const info = [
    { num: 16, str: "함수가 실행되었습니다." },
    { num: 17, str: "함수가 실행되었습니다." },
    ];

    function func(num, str) {
        console.log(`${num}. ${str}`);
    }
    func(info[0].num, info[0].str);
    func(info[1].num, info[1].str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            16. 함수가 실행되었습니다. <br>
                            17. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample15 -->

            <div id="sample16" class="sample">
                <h3>16. 함수 유형 : 객체 안에 함수를 이용한 형태</h3>
                <p>
                    코드에서 객체는 속성 num, str, 그리고 화살표 함수로 정의된 result 함수를 포함하고 있습니다. 이러한 형태의 함수 정의는 객체 내부에서 해당 객체의 속성에 접근할
                    수 있도록 합니다. 화살표 함수는 자체적인 this를 생성하지 않으므로, 함수 내부에서 info 객체의 속성을 사용할 때에는 외부에서 해당 객체에 접근해야 합니다. 이 코드에서는
                    info 객체 내부에서 num과 str을 참조할 때 외부에서 직접 info를 참조하고 있습니다.
                </p>
                <pre><code>{
    const info = {
        num: 18,
        str: "함수가 실행되었습니다",
        result: () => {
            console.log(`${info.num}. ${info.str}`);
        }
    }
    info.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            18. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample16 -->

            <div id="sample17" class="sample">
                <h3>17. 함수 유형 : 객체 생성자 함수 (대문자)</h3>
                <p>
                    객체 생성자 함수는 JavaScript에서 새로운 객체를 만들기 위해 사용되며, new 키워드와 함께 호출됩니다. 이 함수 내부에서는 새로운 객체의 속성과 메서드를 정의하고,
                    그것을 생성하여 반환합니다. 위의 코드에서 Func 생성자 함수는 num과 str을 인수로 받아 새로운 객체를 생성하고, 해당 객체에 result 메서드를 정의합니다. 이렇게
                    생성된 객체는 new 키워드로 호출되어 새로운 인스턴스가 생성되며, 각 인스턴스는 자체적인 result 메서드를 호출하여 동작합니다.
                </p>
                <pre><code>{
    // 함수 정의
    function Func(num, str) {
        this.num = num;
        this.str = str;
        this.result = () => {
            console.log(`${this.num}. ${this.str}`);
        }
    }
    //인스턴스 생성
    const info1 = new Func(19, "함수가 실행되었습니다.");
    const info2 = new Func(20, "함수가 실행되었습니다.");

    //호출
    info1.result();
    info2.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            19. 함수가 실행되었습니다. <br>
                            20. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample17 -->

            <div id="sample18" class="sample">
                <h3>18. 함수 유형: 프로토타입 함수 (prototype)</h3>
                <p>
                    프로토타입 함수는 JavaScript에서 객체가 공유하는 메서드를 정의할 때 사용됩니다. 이 함수는 생성자 함수의 프로토타입 객체에 추가되며, 모든 해당 생성자를 통해 생성된
                    객체가 이를 공유합니다. 이는 여러 객체가 동일한 동작을 공유할 때 메모리를 절약하고 코드를 효율적으로 관리할 수 있게 합니다. 위의 코드에서
                    Func.prototype.result를 통해 모든 Func 객체가 공유하는 result 메서드를 정의하고 있습니다.
                </p>
                <pre><code>{
    // 함수 정의
    function Func(num, str) {
        this.num = num;
        this.str = str;
    }
    //메서드 추가
    Func.prototype.result = function () {
        console.log(`${this.num}. ${this.str}`);
    }

    // 인스턴스 생성
    const info1 = new Func(21, "함수가 실행되었습니다.");
    const info2 = new Func(22, "함수가 실행되었습니다.");

    // 호출
    info1.result();
    info2.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            21. 함수가 실행되었습니다. <br>
                            22. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample18 -->

            <div id="sample19" class="sample">
                <h3>19. 함수 유형 : 객체 리터럴 함수</h3>
                <p>
                    객체 리터럴 함수는 JavaScript에서 객체를 생성하는 방법 중 하나로, 중괄호({})를 사용하여 객체를 정의하고 그 안에 속성과 메서드를 포함시킵니다. 이는 객체를 구조화하고
                    초기화하는 데 유용하며, 객체의 각 요소들을 명시적으로 정의함으로써 코드의 가독성과 유지보수성을 향상시킵니다. 또한, 객체 리터럴 함수를 사용하면 다수의 객체를 간편하게 생성할 수
                    있으며, 각 객체는 자체적으로 독립적인 상태와 동작을 가질 수 있습니다.
                </p>
                <pre><code>{
    // 함수 정의
    function Func(num, str) {
        this.num = num;
        this.str = str;
    }
    // 메서드 추가
    Func.prototype = {
        result1: function () {
            console.log(`${this.num}. ${this.str}`);
        },
        result2: function () {
            console.log(`${this.num}. ${this.str}`);
        },
    }
    // 인스턴스 생성
    const info1 = new Func(23, "함수가 실행되었습니다.");
    const info2 = new Func(24, "함수가 실행되었습니다.");

    // 호출
    info1.result1();
    info2.result2();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            23. 함수가 실행되었습니다. <br>
                            24. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample19 -->
        </div>

        <button id="topBtn" onclick="topFunction()">TOP</button>
    </main>
    <!-- //main -->
    <footer id="footer">

    </footer>
    <!-- //footer -->
    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
        // 11. 함수 유형 : 함수와 매개변수를 이용한 형태
        {
            function func(x, y) {
                console.log(x, y);
            }
            func("01", "실행되었습니다.");
        }
        // 12. 함수 유형 : 함수와 변수를 이용한 형태
        {
            const x = "02.", y = "실행되었습니다."

            function func(x, y) {
                console.log(x, y);
            }
            func(x, y);
        }
        // 13. 함수 유형 : 함수와 배열를 이용한 형태
        {
            const x = ["03.", "04."];
            const y = "실행되었습니다.";

            function func(x, y) {
                console.log(`${x}`, y);
            }
            func(x[0], y);
            func(x[1], y);
        }
        // 14. 함수 유형 : 함수와 객체를 이용한 형태
        {
            const x = {
                a: "05.",
                b: "실행되었습니다."
            }

            function func(x, y) {
                console.log(x, y);
            }
            func(x.a, x.b);
        }
        // 15. 함수 유형 : 함수와 객체 및 배열를 이용한 형태
        {
            const info = [
                { a: "06.", b: "실행되었습니다." },
                { c: "07.", d: "실행되었습니다." }
            ];
            function func(x, y) {
                console.log(x, y);
            }
            func(info[0].a, info[0].b);
            func(info[1].c, info[1].d);
        }

        // 16. 함수 유형 : 객체 안에 함수를 이용한 형태
        {
            const info = {
                num: "08",
                str: "실행되었습니다.",
                result: () => {
                    console.log(`${info.num}. ${info.str}`);
                }
            }
            info.result();
        }

        // 17. 함수 유형 : 객체 생성자 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
                this.result = () => {
                    console.log(`${this.num}. ${this.str}`);
                }
            }
            // 인스턴스 생성
            const info1 = new Func("09", "실행되었습니다.");
            const info2 = new Func("10", "실행되었습니다.");

            // 호출
            info1.result();
            info2.result();
        }

        // 18. 함수 유형 : 프로토타입 함수
        {
            // 함수 정의
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            // 메서드 추가
            Func.prototype.result = function () {
                console.log(`${this.num}. ${this.str}`);
            }

            // 인스턴스 생성
            const info1 = new Func("11", "실행되었습니다.");
            const info2 = new Func("12", "실행되었습니다.");

            // 호출
            info1.result();
            info2.result();
        }

        // 19. 함수 유형 : 객체 리터릴 함수
        {
            // 함수 정의
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }
            // 메서드 추가
            Func.prototype = {
                result1: function () {
                    console.log(`${this.num}. ${this.str}`);
                },
                result2: function () {
                    console.log(`${this.num}. ${this.str}`);
                },
            }

            const info1 = new Func("13", "실행되었습니다.");
            const info2 = new Func("14", "실행되었습니다.");

            info1.result1();
            info2.result2();
        }

        // 20. 함수 : 즉시실행 함수
        {
            (function () {
                console.log("15. 실행되었습니다.");
            })();

            (() => {
                console.log("16. 실행되었습니다.");
            })();
        }

        // 21. 함수 : 파라미터 함수
        {
            function func(str = "17. 실행되었습니다.") {
                console.log(str)
            }
            func();

            const func1 = (str = "18. 실행되었습니다.") => {
                console.log(str)
            }
            func1();
        }
        // 22. 함수 : 재귀 함수
        {
            // 01 반복문을 사용하는 경우  
            function func(num) {
                for (let i = 0; i < num; i++) {
                    console.log("19. 실행되었습니다.");
                }
            }
            func(10);

            // 02. 재귀함수를 사용하기
            function func1(num) {
                if (num < 1) return;

                console.log("20. 실행되었습니다.");
                func1(num - 1); // 재귀 호출
            }
            func1(10);
        }

        // 23. 함수 : 콜백 함수
        {
            // 01 이벤트
            function func() {
                console.log("21. 실행되었습니다.");
            }
            // btn.addEventListener("click", func);

            // 02  함수를 다른 함수의 인자로 전달
            function func1() {
                console.log("22. 실행되었습니다.");
            }
            function func2(callback) {
                callback();
            }
            func2(func1);

            // 03 반복문을 사용하는 경우
            function func3(num) {
                console.log(num + ". 실행되었습니다.")
            }
            function func4(callback) {
                for (let i = 23; i < 28; i++) {
                    callback(i)
                }
            }
            func4(func3);
        }
        // 24. 함수 : 비동기 방식 : 콜백 함수
        // 25. 함수 : 비동기 방식 : 프로미스
        // 26. 함수 : 비동기 방식 : asyne/await
        // 27. 함수 : 중첩 함수
        // 28. 함수 : 클로저

    </script>

    <!-- //버튼 스크립트 -->
    <script>
        let mybutton = document.getElementById("topBtn");

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function () { scrollFunction() };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                mybutton.style.display = "block";
            } else {
                mybutton.style.display = "none";
            }
        }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
            document.body.scrollTop = 0;
            document.documentElement.scrollTop = 0;
        }
    </script>

</body>

</html>